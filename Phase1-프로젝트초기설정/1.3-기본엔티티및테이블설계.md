# 1.3 기본 엔티티 및 테이블 설계

## 개요
배치 작업 관리, 실행 히스토리, 스케줄 관리를 위한 핵심 테이블과 JPA 엔티티를 설계하는 단계입니다.

## 작업 체크리스트

### 배치 작업 관리 테이블 (BATCH_JOB_CONFIG)
- [ ] 테이블 생성 SQL 작성
```sql
-- src/main/resources/schema.sql
CREATE TABLE BATCH_JOB_CONFIG (
    JOB_CONFIG_ID       BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    JOB_NAME           VARCHAR(100) NOT NULL,
    SCHEMA_NAME        VARCHAR(50) NOT NULL DEFAULT 'FAS',
    TABLE_NAME         VARCHAR(100) NOT NULL,
    START_DATE         DATE,
    END_DATE           DATE,
    INSERT_QUERY       CLOB,
    MEMO               VARCHAR(500),
    IS_ACTIVE          CHAR(1) NOT NULL DEFAULT 'Y',
    CREATED_BY         VARCHAR(50) NOT NULL,
    CREATED_DATE       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFIED_BY        VARCHAR(50),
    MODIFIED_DATE      TIMESTAMP,
    CONSTRAINT PK_BATCH_JOB_CONFIG PRIMARY KEY (JOB_CONFIG_ID),
    CONSTRAINT CHK_IS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'))
);

-- 인덱스 생성
CREATE INDEX IDX_BATCH_JOB_CONFIG_01 ON BATCH_JOB_CONFIG(JOB_NAME);
CREATE INDEX IDX_BATCH_JOB_CONFIG_02 ON BATCH_JOB_CONFIG(SCHEMA_NAME, TABLE_NAME);
CREATE INDEX IDX_BATCH_JOB_CONFIG_03 ON BATCH_JOB_CONFIG(IS_ACTIVE);

-- 코멘트 추가
COMMENT ON TABLE BATCH_JOB_CONFIG IS '배치 작업 설정 테이블';
COMMENT ON COLUMN BATCH_JOB_CONFIG.JOB_CONFIG_ID IS '작업 설정 ID (PK)';
COMMENT ON COLUMN BATCH_JOB_CONFIG.JOB_NAME IS '작업명';
COMMENT ON COLUMN BATCH_JOB_CONFIG.SCHEMA_NAME IS '스키마명 (기본값: FAS)';
COMMENT ON COLUMN BATCH_JOB_CONFIG.TABLE_NAME IS '테이블명';
COMMENT ON COLUMN BATCH_JOB_CONFIG.START_DATE IS '시작일';
COMMENT ON COLUMN BATCH_JOB_CONFIG.END_DATE IS '종료일';
COMMENT ON COLUMN BATCH_JOB_CONFIG.INSERT_QUERY IS '삽입 쿼리';
COMMENT ON COLUMN BATCH_JOB_CONFIG.MEMO IS '메모';
COMMENT ON COLUMN BATCH_JOB_CONFIG.IS_ACTIVE IS '활성 여부 (Y/N)';
```

- [ ] BatchJobConfig.java 엔티티 생성
```java
package com.sbs.datasync.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "BATCH_JOB_CONFIG")
@EntityListeners(AuditingEntityListener.class)
public class BatchJobConfig {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "JOB_CONFIG_ID")
    private Long jobConfigId;

    @NotBlank
    @Size(max = 100)
    @Column(name = "JOB_NAME", nullable = false, length = 100)
    private String jobName;

    @NotBlank
    @Size(max = 50)
    @Column(name = "SCHEMA_NAME", nullable = false, length = 50)
    private String schemaName = "FAS";

    @NotBlank
    @Size(max = 100)
    @Column(name = "TABLE_NAME", nullable = false, length = 100)
    private String tableName;

    @Column(name = "START_DATE")
    private LocalDate startDate;

    @Column(name = "END_DATE")
    private LocalDate endDate;

    @Lob
    @Column(name = "INSERT_QUERY")
    private String insertQuery;

    @Size(max = 500)
    @Column(name = "MEMO", length = 500)
    private String memo;

    @NotNull
    @Column(name = "IS_ACTIVE", nullable = false, length = 1)
    private String isActive = "Y";

    @CreatedBy
    @Column(name = "CREATED_BY", nullable = false, length = 50)
    private String createdBy;

    @CreatedDate
    @Column(name = "CREATED_DATE", nullable = false)
    private LocalDateTime createdDate;

    @LastModifiedBy
    @Column(name = "MODIFIED_BY", length = 50)
    private String modifiedBy;

    @LastModifiedDate
    @Column(name = "MODIFIED_DATE")
    private LocalDateTime modifiedDate;

    // Constructors
    public BatchJobConfig() {}

    public BatchJobConfig(String jobName, String schemaName, String tableName) {
        this.jobName = jobName;
        this.schemaName = schemaName;
        this.tableName = tableName;
    }

    // Getters and Setters
    // ... (getter/setter 메서드들)

    // Business methods
    public boolean isActive() {
        return "Y".equals(this.isActive);
    }

    public void activate() {
        this.isActive = "Y";
    }

    public void deactivate() {
        this.isActive = "N";
    }

    @Override
    public String toString() {
        return "BatchJobConfig{" +
                "jobConfigId=" + jobConfigId +
                ", jobName='" + jobName + '\'' +
                ", schemaName='" + schemaName + '\'' +
                ", tableName='" + tableName + '\'' +
                '}';
    }
}
```

### 배치 실행 히스토리 테이블 (BATCH_EXECUTION_HISTORY)
- [ ] 테이블 생성 SQL 작성
```sql
CREATE TABLE BATCH_EXECUTION_HISTORY (
    EXECUTION_ID        BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    JOB_CONFIG_ID       BIGINT NOT NULL,
    JOB_INSTANCE_ID     BIGINT,
    JOB_EXECUTION_ID    BIGINT,
    EXECUTION_STATUS    VARCHAR(20) NOT NULL,
    START_TIME          TIMESTAMP,
    END_TIME            TIMESTAMP,
    DURATION_SECONDS    BIGINT,
    TOTAL_COUNT         BIGINT DEFAULT 0,
    SUCCESS_COUNT       BIGINT DEFAULT 0,
    ERROR_COUNT         BIGINT DEFAULT 0,
    SKIP_COUNT          BIGINT DEFAULT 0,
    ERROR_MESSAGE       CLOB,
    EXECUTION_PARAMS    CLOB,
    EXECUTED_BY         VARCHAR(50),
    CONSTRAINT PK_BATCH_EXECUTION_HISTORY PRIMARY KEY (EXECUTION_ID),
    CONSTRAINT FK_BATCH_EXECUTION_CONFIG FOREIGN KEY (JOB_CONFIG_ID)
        REFERENCES BATCH_JOB_CONFIG(JOB_CONFIG_ID),
    CONSTRAINT CHK_EXECUTION_STATUS CHECK (
        EXECUTION_STATUS IN ('STARTED', 'COMPLETED', 'FAILED', 'STOPPED', 'ABANDONED')
    )
);

-- 인덱스 생성
CREATE INDEX IDX_BATCH_EXECUTION_01 ON BATCH_EXECUTION_HISTORY(JOB_CONFIG_ID);
CREATE INDEX IDX_BATCH_EXECUTION_02 ON BATCH_EXECUTION_HISTORY(EXECUTION_STATUS);
CREATE INDEX IDX_BATCH_EXECUTION_03 ON BATCH_EXECUTION_HISTORY(START_TIME);
CREATE INDEX IDX_BATCH_EXECUTION_04 ON BATCH_EXECUTION_HISTORY(JOB_EXECUTION_ID);

-- 코멘트 추가
COMMENT ON TABLE BATCH_EXECUTION_HISTORY IS '배치 실행 이력 테이블';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.EXECUTION_ID IS '실행 이력 ID (PK)';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.JOB_CONFIG_ID IS '작업 설정 ID (FK)';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.EXECUTION_STATUS IS '실행 상태';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.TOTAL_COUNT IS '전체 처리 건수';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.SUCCESS_COUNT IS '성공 건수';
COMMENT ON COLUMN BATCH_EXECUTION_HISTORY.ERROR_COUNT IS '오류 건수';
```

- [ ] BatchExecutionHistory.java 엔티티 생성
```java
package com.sbs.datasync.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDateTime;

@Entity
@Table(name = "BATCH_EXECUTION_HISTORY")
public class BatchExecutionHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "EXECUTION_ID")
    private Long executionId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "JOB_CONFIG_ID", nullable = false)
    private BatchJobConfig jobConfig;

    @Column(name = "JOB_INSTANCE_ID")
    private Long jobInstanceId;

    @Column(name = "JOB_EXECUTION_ID")
    private Long jobExecutionId;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "EXECUTION_STATUS", nullable = false, length = 20)
    private ExecutionStatus executionStatus;

    @Column(name = "START_TIME")
    private LocalDateTime startTime;

    @Column(name = "END_TIME")
    private LocalDateTime endTime;

    @Column(name = "DURATION_SECONDS")
    private Long durationSeconds;

    @Column(name = "TOTAL_COUNT")
    private Long totalCount = 0L;

    @Column(name = "SUCCESS_COUNT")
    private Long successCount = 0L;

    @Column(name = "ERROR_COUNT")
    private Long errorCount = 0L;

    @Column(name = "SKIP_COUNT")
    private Long skipCount = 0L;

    @Lob
    @Column(name = "ERROR_MESSAGE")
    private String errorMessage;

    @Lob
    @Column(name = "EXECUTION_PARAMS")
    private String executionParams;

    @Column(name = "EXECUTED_BY", length = 50)
    private String executedBy;

    // Constructors, Getters, Setters...

    // Business methods
    public void markAsStarted() {
        this.executionStatus = ExecutionStatus.STARTED;
        this.startTime = LocalDateTime.now();
    }

    public void markAsCompleted() {
        this.executionStatus = ExecutionStatus.COMPLETED;
        this.endTime = LocalDateTime.now();
        calculateDuration();
    }

    public void markAsFailed(String errorMessage) {
        this.executionStatus = ExecutionStatus.FAILED;
        this.endTime = LocalDateTime.now();
        this.errorMessage = errorMessage;
        calculateDuration();
    }

    private void calculateDuration() {
        if (startTime != null && endTime != null) {
            this.durationSeconds = java.time.Duration.between(startTime, endTime).getSeconds();
        }
    }

    public enum ExecutionStatus {
        STARTED, COMPLETED, FAILED, STOPPED, ABANDONED
    }
}
```

### 스케줄 관리 테이블 (BATCH_SCHEDULE)
- [ ] 테이블 생성 SQL 작성
```sql
CREATE TABLE BATCH_SCHEDULE (
    SCHEDULE_ID         BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    JOB_CONFIG_ID       BIGINT NOT NULL,
    SCHEDULE_NAME       VARCHAR(100) NOT NULL,
    CRON_EXPRESSION     VARCHAR(100) NOT NULL,
    IS_ENABLED          CHAR(1) NOT NULL DEFAULT 'Y',
    NEXT_EXECUTION_TIME TIMESTAMP,
    LAST_EXECUTION_TIME TIMESTAMP,
    DESCRIPTION         VARCHAR(500),
    CREATED_BY          VARCHAR(50) NOT NULL,
    CREATED_DATE        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFIED_BY         VARCHAR(50),
    MODIFIED_DATE       TIMESTAMP,
    CONSTRAINT PK_BATCH_SCHEDULE PRIMARY KEY (SCHEDULE_ID),
    CONSTRAINT FK_BATCH_SCHEDULE_CONFIG FOREIGN KEY (JOB_CONFIG_ID)
        REFERENCES BATCH_JOB_CONFIG(JOB_CONFIG_ID),
    CONSTRAINT CHK_SCHEDULE_ENABLED CHECK (IS_ENABLED IN ('Y', 'N')),
    CONSTRAINT UQ_SCHEDULE_NAME UNIQUE (SCHEDULE_NAME)
);

-- 인덱스 생성
CREATE INDEX IDX_BATCH_SCHEDULE_01 ON BATCH_SCHEDULE(JOB_CONFIG_ID);
CREATE INDEX IDX_BATCH_SCHEDULE_02 ON BATCH_SCHEDULE(IS_ENABLED);
CREATE INDEX IDX_BATCH_SCHEDULE_03 ON BATCH_SCHEDULE(NEXT_EXECUTION_TIME);

-- 코멘트 추가
COMMENT ON TABLE BATCH_SCHEDULE IS '배치 스케줄 관리 테이블';
COMMENT ON COLUMN BATCH_SCHEDULE.SCHEDULE_ID IS '스케줄 ID (PK)';
COMMENT ON COLUMN BATCH_SCHEDULE.JOB_CONFIG_ID IS '작업 설정 ID (FK)';
COMMENT ON COLUMN BATCH_SCHEDULE.CRON_EXPRESSION IS '크론 표현식';
COMMENT ON COLUMN BATCH_SCHEDULE.IS_ENABLED IS '활성 여부 (Y/N)';
COMMENT ON COLUMN BATCH_SCHEDULE.NEXT_EXECUTION_TIME IS '다음 실행 예정 시간';
```

- [ ] BatchSchedule.java 엔티티 생성
```java
package com.sbs.datasync.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Table(name = "BATCH_SCHEDULE")
@EntityListeners(AuditingEntityListener.class)
public class BatchSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "SCHEDULE_ID")
    private Long scheduleId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "JOB_CONFIG_ID", nullable = false)
    private BatchJobConfig jobConfig;

    @NotBlank
    @Size(max = 100)
    @Column(name = "SCHEDULE_NAME", nullable = false, length = 100, unique = true)
    private String scheduleName;

    @NotBlank
    @Size(max = 100)
    @Column(name = "CRON_EXPRESSION", nullable = false, length = 100)
    private String cronExpression;

    @NotNull
    @Column(name = "IS_ENABLED", nullable = false, length = 1)
    private String isEnabled = "Y";

    @Column(name = "NEXT_EXECUTION_TIME")
    private LocalDateTime nextExecutionTime;

    @Column(name = "LAST_EXECUTION_TIME")
    private LocalDateTime lastExecutionTime;

    @Size(max = 500)
    @Column(name = "DESCRIPTION", length = 500)
    private String description;

    @CreatedBy
    @Column(name = "CREATED_BY", nullable = false, length = 50)
    private String createdBy;

    @CreatedDate
    @Column(name = "CREATED_DATE", nullable = false)
    private LocalDateTime createdDate;

    @LastModifiedBy
    @Column(name = "MODIFIED_BY", length = 50)
    private String modifiedBy;

    @LastModifiedDate
    @Column(name = "MODIFIED_DATE")
    private LocalDateTime modifiedDate;

    // Constructors, Getters, Setters...

    // Business methods
    public boolean isEnabled() {
        return "Y".equals(this.isEnabled);
    }

    public void enable() {
        this.isEnabled = "Y";
    }

    public void disable() {
        this.isEnabled = "N";
    }

    public void updateLastExecutionTime() {
        this.lastExecutionTime = LocalDateTime.now();
    }
}
```

### 기본 JPA 엔티티 클래스 생성

#### BaseEntity.java (공통 엔티티) 생성
- [ ] src/main/java/com/sbs/datasync/entity/BaseEntity.java 파일 생성
```java
package com.sbs.datasync.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @CreatedBy
    @Column(name = "CREATED_BY", length = 50, updatable = false)
    private String createdBy;

    @CreatedDate
    @Column(name = "CREATED_DATE", updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedBy
    @Column(name = "MODIFIED_BY", length = 50)
    private String modifiedBy;

    @LastModifiedDate
    @Column(name = "MODIFIED_DATE")
    private LocalDateTime modifiedDate;

    // Getters and Setters
    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public LocalDateTime getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(LocalDateTime createdDate) {
        this.createdDate = createdDate;
    }

    public String getModifiedBy() {
        return modifiedBy;
    }

    public void setModifiedBy(String modifiedBy) {
        this.modifiedBy = modifiedBy;
    }

    public LocalDateTime getModifiedDate() {
        return modifiedDate;
    }

    public void setModifiedDate(LocalDateTime modifiedDate) {
        this.modifiedDate = modifiedDate;
    }
}
```

#### JpaAuditingConfig.java 생성
- [ ] src/main/java/com/sbs/datasync/config/JpaAuditingConfig.java 파일 생성
```java
package com.sbs.datasync.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Optional;

@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class JpaAuditingConfig {

    @Bean
    public AuditorAware<String> auditorProvider() {
        return new AuditorAwareImpl();
    }

    public static class AuditorAwareImpl implements AuditorAware<String> {
        @Override
        public Optional<String> getCurrentAuditor() {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

            if (authentication == null || !authentication.isAuthenticated()) {
                return Optional.of("system");
            }

            return Optional.of(authentication.getName());
        }
    }
}
```

### Repository 인터페이스 생성

#### BatchJobConfigRepository.java 생성
- [ ] src/main/java/com/sbs/datasync/repository/BatchJobConfigRepository.java 파일 생성
```java
package com.sbs.datasync.repository;

import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface BatchJobConfigRepository extends JpaRepository<BatchJobConfig, Long> {

    List<BatchJobConfig> findByIsActiveOrderByCreatedDateDesc(String isActive);

    Optional<BatchJobConfig> findByJobNameAndIsActive(String jobName, String isActive);

    List<BatchJobConfig> findBySchemaNameAndIsActiveOrderByTableName(String schemaName, String isActive);

    @Query("SELECT b FROM BatchJobConfig b WHERE " +
           "(:jobName IS NULL OR b.jobName LIKE %:jobName%) AND " +
           "(:schemaName IS NULL OR b.schemaName = :schemaName) AND " +
           "(:tableName IS NULL OR b.tableName LIKE %:tableName%) AND " +
           "b.isActive = :isActive")
    Page<BatchJobConfig> findBySearchConditions(
        @Param("jobName") String jobName,
        @Param("schemaName") String schemaName,
        @Param("tableName") String tableName,
        @Param("isActive") String isActive,
        Pageable pageable
    );

    boolean existsByJobNameAndIsActive(String jobName, String isActive);
}
```

#### BatchExecutionHistoryRepository.java 생성
- [ ] src/main/java/com/sbs/datasync/repository/BatchExecutionHistoryRepository.java 파일 생성
```java
package com.sbs.datasync.repository;

import com.sbs.datasync.entity.BatchExecutionHistory;
import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface BatchExecutionHistoryRepository extends JpaRepository<BatchExecutionHistory, Long> {

    List<BatchExecutionHistory> findByJobConfigOrderByStartTimeDesc(BatchJobConfig jobConfig);

    Page<BatchExecutionHistory> findByJobConfigOrderByStartTimeDesc(BatchJobConfig jobConfig, Pageable pageable);

    Optional<BatchExecutionHistory> findTopByJobConfigAndExecutionStatusOrderByStartTimeDesc(
        BatchJobConfig jobConfig, BatchExecutionHistory.ExecutionStatus status
    );

    @Query("SELECT h FROM BatchExecutionHistory h WHERE " +
           "h.startTime BETWEEN :startTime AND :endTime " +
           "ORDER BY h.startTime DESC")
    List<BatchExecutionHistory> findByDateRange(
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime
    );

    @Query("SELECT COUNT(h) FROM BatchExecutionHistory h WHERE " +
           "h.executionStatus = :status AND " +
           "h.startTime >= :fromDate")
    long countByStatusAndDateAfter(
        @Param("status") BatchExecutionHistory.ExecutionStatus status,
        @Param("fromDate") LocalDateTime fromDate
    );
}
```

#### BatchScheduleRepository.java 생성
- [ ] src/main/java/com/sbs/datasync/repository/BatchScheduleRepository.java 파일 생성
```java
package com.sbs.datasync.repository;

import com.sbs.datasync.entity.BatchSchedule;
import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface BatchScheduleRepository extends JpaRepository<BatchSchedule, Long> {

    List<BatchSchedule> findByIsEnabledOrderByNextExecutionTime(String isEnabled);

    Optional<BatchSchedule> findByScheduleNameAndIsEnabled(String scheduleName, String isEnabled);

    List<BatchSchedule> findByJobConfigAndIsEnabled(BatchJobConfig jobConfig, String isEnabled);

    @Query("SELECT s FROM BatchSchedule s WHERE " +
           "s.isEnabled = 'Y' AND " +
           "s.nextExecutionTime <= :currentTime " +
           "ORDER BY s.nextExecutionTime")
    List<BatchSchedule> findSchedulesToExecute(@Param("currentTime") LocalDateTime currentTime);

    boolean existsByScheduleNameAndIsEnabled(String scheduleName, String isEnabled);
}
```

## 완료 확인 방법

### 테이블 생성 확인
- [ ] 데이터베이스에서 테이블 생성 확인
```sql
SELECT TABLE_NAME FROM SYSCAT.TABLES
WHERE TABSCHEMA = 'YOUR_SCHEMA'
AND TABLE_NAME IN ('BATCH_JOB_CONFIG', 'BATCH_EXECUTION_HISTORY', 'BATCH_SCHEDULE');
```

### 엔티티 매핑 확인
- [ ] JPA 엔티티 스캔 로그 확인
- [ ] Hibernate DDL 검증 로그 확인

### Repository 테스트
- [ ] 각 Repository의 기본 CRUD 동작 테스트
```java
@Test
void testBatchJobConfigRepository() {
    BatchJobConfig config = new BatchJobConfig("TEST_JOB", "FAS", "TEST_TABLE");
    BatchJobConfig saved = batchJobConfigRepository.save(config);
    assertThat(saved.getJobConfigId()).isNotNull();
}
```

### 데이터 샘플 삽입 테스트
- [ ] 각 테이블에 샘플 데이터 삽입 및 조회 테스트

## 주의 사항
- DB2 데이터타입 호환성 확인
- 외래키 제약조건 설정 확인
- 인덱스 성능 고려
- JPA 엔티티 연관관계 설정 주의

## 다음 단계
Phase 2: 백엔드 핵심 기능 개발로 진행