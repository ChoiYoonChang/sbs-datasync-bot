# 2.3 REST API 개발

## 개요
배치 작업 관리, 실행, 상태 조회, 히스토리 관리를 위한 REST API를 개발하는 단계입니다.

## 작업 체크리스트

### 배치 작업 CRUD API

#### BatchJobConfigController.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/BatchJobConfigController.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.BatchJobConfigDto;
import com.sbs.datasync.entity.BatchJobConfig;
import com.sbs.datasync.service.BatchJobConfigService;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/batch/jobs")
@CrossOrigin(origins = "http://localhost:5173") // React 개발 서버
public class BatchJobConfigController {

    private final BatchJobConfigService batchJobConfigService;

    public BatchJobConfigController(BatchJobConfigService batchJobConfigService) {
        this.batchJobConfigService = batchJobConfigService;
    }

    /**
     * 배치 작업 목록 조회 (페이징)
     */
    @GetMapping
    public ResponseEntity<Page<BatchJobConfigDto.Response>> getJobConfigs(
            @RequestParam(required = false) String jobName,
            @RequestParam(required = false) String schemaName,
            @RequestParam(required = false) String tableName,
            @RequestParam(defaultValue = "Y") String isActive,
            Pageable pageable) {

        Page<BatchJobConfigDto.Response> jobConfigs = batchJobConfigService
            .getJobConfigs(jobName, schemaName, tableName, isActive, pageable);

        return ResponseEntity.ok(jobConfigs);
    }

    /**
     * 활성 배치 작업 목록 조회
     */
    @GetMapping("/active")
    public ResponseEntity<List<BatchJobConfigDto.Response>> getActiveJobConfigs() {
        List<BatchJobConfigDto.Response> activeJobs = batchJobConfigService.getActiveJobConfigs();
        return ResponseEntity.ok(activeJobs);
    }

    /**
     * 배치 작업 상세 조회
     */
    @GetMapping("/{jobConfigId}")
    public ResponseEntity<BatchJobConfigDto.Response> getJobConfig(@PathVariable Long jobConfigId) {
        BatchJobConfigDto.Response jobConfig = batchJobConfigService.getJobConfig(jobConfigId);
        return ResponseEntity.ok(jobConfig);
    }

    /**
     * 배치 작업 생성
     */
    @PostMapping
    public ResponseEntity<BatchJobConfigDto.Response> createJobConfig(
            @Valid @RequestBody BatchJobConfigDto.CreateRequest request) {

        BatchJobConfigDto.Response created = batchJobConfigService.createJobConfig(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * 배치 작업 수정
     */
    @PutMapping("/{jobConfigId}")
    public ResponseEntity<BatchJobConfigDto.Response> updateJobConfig(
            @PathVariable Long jobConfigId,
            @Valid @RequestBody BatchJobConfigDto.UpdateRequest request) {

        BatchJobConfigDto.Response updated = batchJobConfigService.updateJobConfig(jobConfigId, request);
        return ResponseEntity.ok(updated);
    }

    /**
     * 배치 작업 삭제 (비활성화)
     */
    @DeleteMapping("/{jobConfigId}")
    public ResponseEntity<Void> deleteJobConfig(@PathVariable Long jobConfigId) {
        batchJobConfigService.deleteJobConfig(jobConfigId);
        return ResponseEntity.noContent().build();
    }

    /**
     * 배치 작업 활성화/비활성화
     */
    @PatchMapping("/{jobConfigId}/status")
    public ResponseEntity<BatchJobConfigDto.Response> updateJobStatus(
            @PathVariable Long jobConfigId,
            @RequestParam String status) {

        BatchJobConfigDto.Response updated = batchJobConfigService.updateJobStatus(jobConfigId, status);
        return ResponseEntity.ok(updated);
    }

    /**
     * 작업명 중복 확인
     */
    @GetMapping("/check-name")
    public ResponseEntity<Boolean> checkJobNameExists(@RequestParam String jobName) {
        boolean exists = batchJobConfigService.isJobNameExists(jobName);
        return ResponseEntity.ok(exists);
    }
}
```

### 배치 실행 API (수동 실행)

#### BatchExecutionController.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/BatchExecutionController.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.BatchExecutionDto;
import com.sbs.datasync.service.BatchExecutionService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/batch/execution")
@CrossOrigin(origins = "http://localhost:5173")
public class BatchExecutionController {

    private final BatchExecutionService batchExecutionService;

    public BatchExecutionController(BatchExecutionService batchExecutionService) {
        this.batchExecutionService = batchExecutionService;
    }

    /**
     * 배치 작업 수동 실행
     */
    @PostMapping("/run/{jobConfigId}")
    public ResponseEntity<BatchExecutionDto.Response> executeJob(
            @PathVariable Long jobConfigId,
            @RequestParam(required = false) String executedBy) {

        BatchExecutionDto.Response execution = batchExecutionService.executeJob(jobConfigId, executedBy);
        return ResponseEntity.ok(execution);
    }

    /**
     * 배치 작업 비동기 실행
     */
    @PostMapping("/run-async/{jobConfigId}")
    public ResponseEntity<BatchExecutionDto.AsyncResponse> executeJobAsync(
            @PathVariable Long jobConfigId,
            @RequestParam(required = false) String executedBy) {

        BatchExecutionDto.AsyncResponse execution = batchExecutionService.executeJobAsync(jobConfigId, executedBy);
        return ResponseEntity.accepted().body(execution);
    }

    /**
     * 다중 배치 작업 실행
     */
    @PostMapping("/run-multiple")
    public ResponseEntity<List<BatchExecutionDto.Response>> executeMultipleJobs(
            @RequestBody BatchExecutionDto.MultipleExecutionRequest request) {

        List<BatchExecutionDto.Response> executions = batchExecutionService
            .executeMultipleJobs(request.getJobConfigIds(), request.getExecutedBy());

        return ResponseEntity.ok(executions);
    }

    /**
     * 배치 작업 중단
     */
    @PostMapping("/stop/{executionId}")
    public ResponseEntity<Void> stopJob(@PathVariable Long executionId) {
        batchExecutionService.stopJob(executionId);
        return ResponseEntity.ok().build();
    }

    /**
     * 배치 작업 재시작
     */
    @PostMapping("/restart/{executionId}")
    public ResponseEntity<BatchExecutionDto.Response> restartJob(@PathVariable Long executionId) {
        BatchExecutionDto.Response execution = batchExecutionService.restartJob(executionId);
        return ResponseEntity.ok(execution);
    }
}
```

### 배치 상태 조회 API

#### BatchStatusController.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/BatchStatusController.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.BatchStatusDto;
import com.sbs.datasync.service.BatchStatusService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/batch/status")
@CrossOrigin(origins = "http://localhost:5173")
public class BatchStatusController {

    private final BatchStatusService batchStatusService;

    public BatchStatusController(BatchStatusService batchStatusService) {
        this.batchStatusService = batchStatusService;
    }

    /**
     * 실행 중인 배치 작업 목록 조회
     */
    @GetMapping("/running")
    public ResponseEntity<List<BatchStatusDto.RunningJobResponse>> getRunningJobs() {
        List<BatchStatusDto.RunningJobResponse> runningJobs = batchStatusService.getRunningJobs();
        return ResponseEntity.ok(runningJobs);
    }

    /**
     * 특정 배치 실행 상태 조회
     */
    @GetMapping("/{executionId}")
    public ResponseEntity<BatchStatusDto.DetailResponse> getExecutionStatus(@PathVariable Long executionId) {
        BatchStatusDto.DetailResponse status = batchStatusService.getExecutionStatus(executionId);
        return ResponseEntity.ok(status);
    }

    /**
     * Job Config별 최근 실행 상태 조회
     */
    @GetMapping("/latest/{jobConfigId}")
    public ResponseEntity<BatchStatusDto.LatestExecutionResponse> getLatestExecutionStatus(
            @PathVariable Long jobConfigId) {

        BatchStatusDto.LatestExecutionResponse status = batchStatusService
            .getLatestExecutionStatus(jobConfigId);
        return ResponseEntity.ok(status);
    }

    /**
     * 배치 실행 진행률 조회 (실시간)
     */
    @GetMapping("/progress/{executionId}")
    public ResponseEntity<BatchStatusDto.ProgressResponse> getExecutionProgress(
            @PathVariable Long executionId) {

        BatchStatusDto.ProgressResponse progress = batchStatusService.getExecutionProgress(executionId);
        return ResponseEntity.ok(progress);
    }

    /**
     * 전체 시스템 상태 대시보드
     */
    @GetMapping("/dashboard")
    public ResponseEntity<BatchStatusDto.DashboardResponse> getDashboard() {
        BatchStatusDto.DashboardResponse dashboard = batchStatusService.getDashboard();
        return ResponseEntity.ok(dashboard);
    }

    /**
     * 실행 통계 조회
     */
    @GetMapping("/statistics")
    public ResponseEntity<BatchStatusDto.StatisticsResponse> getStatistics(
            @RequestParam(required = false) String period,
            @RequestParam(required = false) Long jobConfigId) {

        BatchStatusDto.StatisticsResponse statistics = batchStatusService
            .getStatistics(period, jobConfigId);
        return ResponseEntity.ok(statistics);
    }
}
```

### 히스토리 조회 API

#### BatchHistoryController.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/BatchHistoryController.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.BatchHistoryDto;
import com.sbs.datasync.service.BatchHistoryService;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/batch/history")
@CrossOrigin(origins = "http://localhost:5173")
public class BatchHistoryController {

    private final BatchHistoryService batchHistoryService;

    public BatchHistoryController(BatchHistoryService batchHistoryService) {
        this.batchHistoryService = batchHistoryService;
    }

    /**
     * 배치 실행 히스토리 목록 조회 (페이징)
     */
    @GetMapping
    public ResponseEntity<Page<BatchHistoryDto.Response>> getExecutionHistory(
            @RequestParam(required = false) Long jobConfigId,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate,
            @RequestParam(required = false) String executedBy,
            Pageable pageable) {

        Page<BatchHistoryDto.Response> history = batchHistoryService
            .getExecutionHistory(jobConfigId, status, startDate, endDate, executedBy, pageable);

        return ResponseEntity.ok(history);
    }

    /**
     * 배치 실행 히스토리 상세 조회
     */
    @GetMapping("/{executionId}")
    public ResponseEntity<BatchHistoryDto.DetailResponse> getExecutionDetail(
            @PathVariable Long executionId) {

        BatchHistoryDto.DetailResponse detail = batchHistoryService.getExecutionDetail(executionId);
        return ResponseEntity.ok(detail);
    }

    /**
     * Job Config별 실행 히스토리 조회
     */
    @GetMapping("/job/{jobConfigId}")
    public ResponseEntity<Page<BatchHistoryDto.Response>> getJobExecutionHistory(
            @PathVariable Long jobConfigId,
            Pageable pageable) {

        Page<BatchHistoryDto.Response> history = batchHistoryService
            .getJobExecutionHistory(jobConfigId, pageable);

        return ResponseEntity.ok(history);
    }

    /**
     * 실행 결과 통계 조회
     */
    @GetMapping("/statistics/{jobConfigId}")
    public ResponseEntity<BatchHistoryDto.StatisticsResponse> getJobStatistics(
            @PathVariable Long jobConfigId,
            @RequestParam(required = false, defaultValue = "30") int days) {

        BatchHistoryDto.StatisticsResponse statistics = batchHistoryService
            .getJobStatistics(jobConfigId, days);

        return ResponseEntity.ok(statistics);
    }

    /**
     * 최근 실행 결과 조회
     */
    @GetMapping("/recent")
    public ResponseEntity<List<BatchHistoryDto.RecentResponse>> getRecentExecutions(
            @RequestParam(defaultValue = "10") int limit) {

        List<BatchHistoryDto.RecentResponse> recentExecutions = batchHistoryService
            .getRecentExecutions(limit);

        return ResponseEntity.ok(recentExecutions);
    }

    /**
     * 실행 로그 조회
     */
    @GetMapping("/{executionId}/logs")
    public ResponseEntity<BatchHistoryDto.LogResponse> getExecutionLogs(
            @PathVariable Long executionId) {

        BatchHistoryDto.LogResponse logs = batchHistoryService.getExecutionLogs(executionId);
        return ResponseEntity.ok(logs);
    }

    /**
     * 히스토리 데이터 내보내기
     */
    @GetMapping("/export")
    public ResponseEntity<BatchHistoryDto.ExportResponse> exportExecutionHistory(
            @RequestParam(required = false) Long jobConfigId,
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate,
            @RequestParam(defaultValue = "CSV") String format) {

        BatchHistoryDto.ExportResponse exportData = batchHistoryService
            .exportExecutionHistory(jobConfigId, startDate, endDate, format);

        return ResponseEntity.ok(exportData);
    }
}
```

### 스케줄 관리 API

#### BatchScheduleController.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/BatchScheduleController.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.BatchScheduleDto;
import com.sbs.datasync.service.BatchScheduleService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/batch/schedule")
@CrossOrigin(origins = "http://localhost:5173")
public class BatchScheduleController {

    private final BatchScheduleService batchScheduleService;

    public BatchScheduleController(BatchScheduleService batchScheduleService) {
        this.batchScheduleService = batchScheduleService;
    }

    /**
     * 스케줄 목록 조회
     */
    @GetMapping
    public ResponseEntity<List<BatchScheduleDto.Response>> getSchedules(
            @RequestParam(defaultValue = "Y") String isEnabled) {

        List<BatchScheduleDto.Response> schedules = batchScheduleService.getSchedules(isEnabled);
        return ResponseEntity.ok(schedules);
    }

    /**
     * 스케줄 상세 조회
     */
    @GetMapping("/{scheduleId}")
    public ResponseEntity<BatchScheduleDto.Response> getSchedule(@PathVariable Long scheduleId) {
        BatchScheduleDto.Response schedule = batchScheduleService.getSchedule(scheduleId);
        return ResponseEntity.ok(schedule);
    }

    /**
     * 스케줄 생성
     */
    @PostMapping
    public ResponseEntity<BatchScheduleDto.Response> createSchedule(
            @Valid @RequestBody BatchScheduleDto.CreateRequest request) {

        BatchScheduleDto.Response created = batchScheduleService.createSchedule(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * 스케줄 수정
     */
    @PutMapping("/{scheduleId}")
    public ResponseEntity<BatchScheduleDto.Response> updateSchedule(
            @PathVariable Long scheduleId,
            @Valid @RequestBody BatchScheduleDto.UpdateRequest request) {

        BatchScheduleDto.Response updated = batchScheduleService.updateSchedule(scheduleId, request);
        return ResponseEntity.ok(updated);
    }

    /**
     * 스케줄 삭제
     */
    @DeleteMapping("/{scheduleId}")
    public ResponseEntity<Void> deleteSchedule(@PathVariable Long scheduleId) {
        batchScheduleService.deleteSchedule(scheduleId);
        return ResponseEntity.noContent().build();
    }

    /**
     * 스케줄 활성화/비활성화
     */
    @PatchMapping("/{scheduleId}/status")
    public ResponseEntity<BatchScheduleDto.Response> updateScheduleStatus(
            @PathVariable Long scheduleId,
            @RequestParam String status) {

        BatchScheduleDto.Response updated = batchScheduleService.updateScheduleStatus(scheduleId, status);
        return ResponseEntity.ok(updated);
    }

    /**
     * 다음 실행 예정 시간 목록
     */
    @GetMapping("/next-executions")
    public ResponseEntity<List<BatchScheduleDto.NextExecutionResponse>> getNextExecutions() {
        List<BatchScheduleDto.NextExecutionResponse> nextExecutions = batchScheduleService
            .getNextExecutions();
        return ResponseEntity.ok(nextExecutions);
    }

    /**
     * 크론 표현식 검증
     */
    @PostMapping("/validate-cron")
    public ResponseEntity<BatchScheduleDto.CronValidationResponse> validateCronExpression(
            @RequestBody BatchScheduleDto.CronValidationRequest request) {

        BatchScheduleDto.CronValidationResponse validation = batchScheduleService
            .validateCronExpression(request.getCronExpression());

        return ResponseEntity.ok(validation);
    }

    /**
     * 스케줄 즉시 실행
     */
    @PostMapping("/{scheduleId}/trigger")
    public ResponseEntity<BatchScheduleDto.TriggerResponse> triggerSchedule(
            @PathVariable Long scheduleId) {

        BatchScheduleDto.TriggerResponse trigger = batchScheduleService.triggerSchedule(scheduleId);
        return ResponseEntity.ok(trigger);
    }
}
```

### 공통 예외 처리

#### GlobalExceptionHandler.java 생성
- [ ] src/main/java/com/sbs/datasync/controller/GlobalExceptionHandler.java 파일 생성
```java
package com.sbs.datasync.controller;

import com.sbs.datasync.dto.ErrorResponse;
import com.sbs.datasync.exception.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BatchJobConfigNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleBatchJobConfigNotFound(
            BatchJobConfigNotFoundException ex) {

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.NOT_FOUND.value())
            .error("Not Found")
            .message(ex.getMessage())
            .path("/api/batch/jobs")
            .build();

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(BatchExecutionException.class)
    public ResponseEntity<ErrorResponse> handleBatchExecution(BatchExecutionException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("Batch Execution Error")
            .message(ex.getMessage())
            .path("/api/batch/execution")
            .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    @ExceptionHandler(InvalidJobConfigException.class)
    public ResponseEntity<ErrorResponse> handleInvalidJobConfig(InvalidJobConfigException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Invalid Job Configuration")
            .message(ex.getMessage())
            .path("/api/batch/jobs")
            .build();

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(ScheduleException.class)
    public ResponseEntity<ErrorResponse> handleScheduleException(ScheduleException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Schedule Error")
            .message(ex.getMessage())
            .path("/api/batch/schedule")
            .build();

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Validation Failed")
            .message("입력값 검증에 실패했습니다")
            .validationErrors(errors)
            .build();

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(DatabaseConnectionException.class)
    public ResponseEntity<ErrorResponse> handleDatabaseConnection(DatabaseConnectionException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.SERVICE_UNAVAILABLE.value())
            .error("Database Connection Error")
            .message(ex.getMessage())
            .build();

        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("Internal Server Error")
            .message("서버 내부 오류가 발생했습니다")
            .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

### API 문서화 설정

#### OpenApiConfig.java 생성
- [ ] src/main/java/com/sbs/datasync/config/OpenApiConfig.java 파일 생성
```java
package com.sbs.datasync.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("SBS 데이터 동기화 배치 시스템 API")
                .description("ERP 시스템 데이터베이스 클론 배치 프로그램 REST API")
                .version("1.0.0")
                .contact(new Contact()
                    .name("SBS Development Team")
                    .email("dev@sbs.co.kr"))
                .license(new License()
                    .name("Internal Use Only")
                    .url("http://internal.sbs.co.kr/license")));
    }
}
```

### build.gradle에 의존성 추가
- [ ] OpenAPI 문서화를 위한 의존성 추가
```gradle
dependencies {
    // ... 기존 의존성들

    // API 문서화
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'

    // 추가 검증
    implementation 'org.springframework.boot:spring-boot-starter-validation'
}
```

## 완료 확인 방법

### API 엔드포인트 테스트
- [ ] 모든 Controller의 기본 엔드포인트 동작 확인
- [ ] POST /api/batch/jobs (배치 작업 생성) 테스트
- [ ] GET /api/batch/jobs (배치 작업 목록 조회) 테스트
- [ ] POST /api/batch/execution/run/{jobConfigId} (배치 실행) 테스트

### API 문서화 확인
- [ ] http://localhost:8080/swagger-ui.html 접근 가능 확인
- [ ] 모든 API 엔드포인트가 문서에 정상 표시되는지 확인

### 예외 처리 테스트
- [ ] 잘못된 요청에 대한 적절한 에러 응답 확인
- [ ] 유효성 검증 실패 시 에러 메시지 확인

### CORS 설정 확인
- [ ] React 개발 서버에서 API 호출 가능 확인

### 응답 형식 검증
- [ ] 모든 API의 응답이 일관된 형식으로 반환되는지 확인
- [ ] 페이징 응답 형식 확인

## 주의 사항
- API 응답 시간 최적화 고려
- 대용량 데이터 조회 시 페이징 처리 필수
- 보안 헤더 설정 고려
- API 버전 관리 전략 수립

## 다음 단계
2.4 서비스 레이어 개발로 진행