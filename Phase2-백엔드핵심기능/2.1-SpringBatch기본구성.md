# 2.1 Spring Batch 기본 구성

## 개요
Spring Batch 프레임워크의 핵심 구성요소인 JobRepository, TransactionManager, Job/Step 템플릿을 설정하는 단계입니다.

## 작업 체크리스트

### BatchConfiguration 클래스 생성
- [ ] src/main/java/com/sbs/datasync/config/BatchConfiguration.java 파일 생성
```java
package com.sbs.datasync.config;

import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.explore.support.JobExplorerFactoryBean;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.launch.support.TaskExecutorJobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.repository.support.JobRepositoryFactoryBean;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing
public class BatchConfiguration {

    private final DataSource primaryDataSource;

    public BatchConfiguration(@Qualifier("primaryDataSource") DataSource primaryDataSource) {
        this.primaryDataSource = primaryDataSource;
    }

    @Bean
    public PlatformTransactionManager batchTransactionManager() {
        return new DataSourceTransactionManager(primaryDataSource);
    }

    @Bean
    public JobRepository jobRepository() throws Exception {
        JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();
        factory.setDataSource(primaryDataSource);
        factory.setTransactionManager(batchTransactionManager());
        factory.setIsolationLevelForCreate("ISOLATION_SERIALIZABLE");
        factory.setTablePrefix("BATCH_");
        factory.setMaxVarCharLength(1000);
        factory.afterPropertiesSet();
        return factory.getObject();
    }

    @Bean
    public JobLauncher jobLauncher() throws Exception {
        TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();
        jobLauncher.setJobRepository(jobRepository());
        jobLauncher.setTaskExecutor(taskExecutor());
        jobLauncher.afterPropertiesSet();
        return jobLauncher;
    }

    @Bean
    public JobExplorer jobExplorer() throws Exception {
        JobExplorerFactoryBean factory = new JobExplorerFactoryBean();
        factory.setDataSource(primaryDataSource);
        factory.setTablePrefix("BATCH_");
        factory.afterPropertiesSet();
        return factory.getObject();
    }

    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(4);
        executor.setMaxPoolSize(8);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("batch-");
        executor.initialize();
        return executor;
    }
}
```

### JobRepository 설정
- [ ] Spring Batch 메타테이블 생성 스크립트 확인
```sql
-- src/main/resources/org/springframework/batch/core/schema-db2.sql 확인
-- 기본적으로 Spring Boot가 자동으로 처리하지만 수동 설정 시 필요

-- BATCH_JOB_INSTANCE 테이블
CREATE TABLE BATCH_JOB_INSTANCE (
    JOB_INSTANCE_ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    VERSION BIGINT,
    JOB_NAME VARCHAR(100) NOT NULL,
    JOB_KEY VARCHAR(32) NOT NULL,
    CONSTRAINT PK_BATCH_JOB_INSTANCE PRIMARY KEY (JOB_INSTANCE_ID)
);

-- BATCH_JOB_EXECUTION 테이블
CREATE TABLE BATCH_JOB_EXECUTION (
    JOB_EXECUTION_ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    VERSION BIGINT,
    JOB_INSTANCE_ID BIGINT NOT NULL,
    CREATE_TIME TIMESTAMP NOT NULL,
    START_TIME TIMESTAMP,
    END_TIME TIMESTAMP,
    STATUS VARCHAR(10),
    EXIT_CODE VARCHAR(2500),
    EXIT_MESSAGE VARCHAR(2500),
    LAST_UPDATED TIMESTAMP,
    CONSTRAINT PK_BATCH_JOB_EXECUTION PRIMARY KEY (JOB_EXECUTION_ID),
    CONSTRAINT FK_JOB_EXECUTION_INST FOREIGN KEY (JOB_INSTANCE_ID)
        REFERENCES BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
);

-- BATCH_STEP_EXECUTION 테이블
CREATE TABLE BATCH_STEP_EXECUTION (
    STEP_EXECUTION_ID BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    VERSION BIGINT NOT NULL,
    STEP_NAME VARCHAR(100) NOT NULL,
    JOB_EXECUTION_ID BIGINT NOT NULL,
    START_TIME TIMESTAMP NOT NULL,
    END_TIME TIMESTAMP,
    STATUS VARCHAR(10),
    COMMIT_COUNT BIGINT,
    READ_COUNT BIGINT,
    FILTER_COUNT BIGINT,
    WRITE_COUNT BIGINT,
    READ_SKIP_COUNT BIGINT,
    WRITE_SKIP_COUNT BIGINT,
    PROCESS_SKIP_COUNT BIGINT,
    ROLLBACK_COUNT BIGINT,
    EXIT_CODE VARCHAR(2500),
    EXIT_MESSAGE VARCHAR(2500),
    LAST_UPDATED TIMESTAMP,
    CONSTRAINT PK_BATCH_STEP_EXECUTION PRIMARY KEY (STEP_EXECUTION_ID),
    CONSTRAINT FK_STEP_EXECUTION_JOB FOREIGN KEY (JOB_EXECUTION_ID)
        REFERENCES BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
);

-- 추가 메타테이블들...
```

- [ ] 배치 메타데이터 초기화 설정
```yaml
# application.yml에 추가
spring:
  batch:
    jdbc:
      initialize-schema: always  # 개발환경
      table-prefix: BATCH_
    job:
      enabled: false  # 자동 실행 방지
```

### PlatformTransactionManager 설정
- [ ] 트랜잭션 매니저 추가 설정
```java
@Configuration
public class TransactionConfig {

    @Bean(name = "batchTransactionManager")
    @Primary
    public PlatformTransactionManager batchTransactionManager(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        DataSourceTransactionManager transactionManager =
            new DataSourceTransactionManager(dataSource);
        transactionManager.setGlobalRollbackOnParticipationFailure(false);
        return transactionManager;
    }

    @Bean(name = "sourceTransactionManager")
    public PlatformTransactionManager sourceTransactionManager(
            @Qualifier("sourceDataSource") DataSource dataSource) {
        DataSourceTransactionManager transactionManager =
            new DataSourceTransactionManager(dataSource);
        transactionManager.setDefaultTimeout(30);
        return transactionManager;
    }
}
```

### 기본 Job/Step 템플릿 생성

#### AbstractBatchJob.java 생성
- [ ] src/main/java/com/sbs/datasync/batch/job/AbstractBatchJob.java 파일 생성
```java
package com.sbs.datasync.batch.job;

import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.transaction.PlatformTransactionManager;

import java.time.LocalDateTime;

public abstract class AbstractBatchJob implements JobExecutionListener {

    protected final JobRepository jobRepository;
    protected final PlatformTransactionManager transactionManager;

    protected AbstractBatchJob(JobRepository jobRepository,
                              PlatformTransactionManager transactionManager) {
        this.jobRepository = jobRepository;
        this.transactionManager = transactionManager;
    }

    // 추상 메서드 - 구현체에서 재정의
    public abstract Job createJob();
    protected abstract Step createMainStep();
    public abstract String getJobName();

    // 공통 Job 빌더
    protected JobBuilder getJobBuilder() {
        return new JobBuilder(getJobName(), jobRepository)
                .listener(this);
    }

    // 공통 Step 빌더
    protected StepBuilder getStepBuilder(String stepName) {
        return new StepBuilder(stepName, jobRepository)
                .transactionManager(transactionManager);
    }

    // JobExecutionListener 구현
    @Override
    public void beforeJob(JobExecution jobExecution) {
        JobParameters parameters = jobExecution.getJobParameters();

        System.out.println("=== Job 시작 ===");
        System.out.println("Job Name: " + jobExecution.getJobInstance().getJobName());
        System.out.println("Job ID: " + jobExecution.getId());
        System.out.println("Start Time: " + LocalDateTime.now());
        System.out.println("Parameters: " + parameters.toString());

        // 배치 실행 히스토리 시작 기록
        recordExecutionStart(jobExecution);
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        System.out.println("=== Job 완료 ===");
        System.out.println("Job Name: " + jobExecution.getJobInstance().getJobName());
        System.out.println("Status: " + jobExecution.getStatus());
        System.out.println("End Time: " + LocalDateTime.now());
        System.out.println("Duration: " +
            java.time.Duration.between(
                jobExecution.getStartTime().toLocalDateTime(),
                LocalDateTime.now()
            ).getSeconds() + " seconds");

        // 배치 실행 히스토리 완료 기록
        recordExecutionEnd(jobExecution);
    }

    // 실행 히스토리 기록 (구현체에서 재정의 가능)
    protected void recordExecutionStart(JobExecution jobExecution) {
        // BatchExecutionHistory 엔티티에 시작 기록
        // 기본 구현 또는 추상화
    }

    protected void recordExecutionEnd(JobExecution jobExecution) {
        // BatchExecutionHistory 엔티티에 완료 기록
        // 기본 구현 또는 추상화
    }

    // 유틸리티 메서드
    protected Long getJobConfigId(JobParameters parameters) {
        return parameters.getLong("jobConfigId");
    }

    protected String getParameterValue(JobParameters parameters, String key, String defaultValue) {
        String value = parameters.getString(key);
        return value != null ? value : defaultValue;
    }
}
```

#### DataSyncJob.java 템플릿 생성
- [ ] src/main/java/com/sbs/datasync/batch/job/DataSyncJob.java 파일 생성
```java
package com.sbs.datasync.batch.job;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
public class DataSyncJob extends AbstractBatchJob {

    private final DataSource sourceDataSource;
    private final DataSource targetDataSource;

    public DataSyncJob(JobRepository jobRepository,
                       PlatformTransactionManager transactionManager,
                       @Qualifier("sourceDataSource") DataSource sourceDataSource,
                       @Qualifier("primaryDataSource") DataSource targetDataSource) {
        super(jobRepository, transactionManager);
        this.sourceDataSource = sourceDataSource;
        this.targetDataSource = targetDataSource;
    }

    @Override
    public String getJobName() {
        return "dataSyncJob";
    }

    @Bean
    @Override
    public Job createJob() {
        return getJobBuilder()
                .start(createMainStep())
                .build();
    }

    @Bean
    @Override
    protected Step createMainStep() {
        return getStepBuilder("dataSyncStep")
                .tasklet(dataSyncTasklet())
                .build();
    }

    @Bean
    public Tasklet dataSyncTasklet() {
        return (contribution, chunkContext) -> {
            // 임시 구현 - 나중에 실제 데이터 동기화 로직으로 대체
            System.out.println("데이터 동기화 작업 실행 중...");

            // JobParameters에서 설정 정보 가져오기
            Long jobConfigId = (Long) chunkContext.getStepContext()
                .getJobParameters().get("jobConfigId");

            System.out.println("Job Config ID: " + jobConfigId);

            // TODO: 실제 데이터 동기화 로직 구현
            // 1. JobConfig 조회
            // 2. Source DB에서 데이터 조회
            // 3. Target DB로 데이터 삽입

            return RepeatStatus.FINISHED;
        };
    }

    // 추가 Step 정의 (필요시)
    @Bean
    public Step validationStep() {
        return getStepBuilder("validationStep")
                .tasklet((contribution, chunkContext) -> {
                    System.out.println("데이터 검증 작업 실행 중...");
                    // 데이터 검증 로직
                    return RepeatStatus.FINISHED;
                })
                .build();
    }

    @Bean
    public Step cleanupStep() {
        return getStepBuilder("cleanupStep")
                .tasklet((contribution, chunkContext) -> {
                    System.out.println("정리 작업 실행 중...");
                    // 임시 데이터 정리 등
                    return RepeatStatus.FINISHED;
                })
                .build();
    }
}
```

#### BatchJobFactory.java 생성
- [ ] src/main/java/com/sbs/datasync/batch/job/BatchJobFactory.java 파일 생성
```java
package com.sbs.datasync.batch.job;

import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class BatchJobFactory {

    private final Map<String, Job> jobRegistry = new ConcurrentHashMap<>();
    private final DataSyncJob dataSyncJob;

    public BatchJobFactory(DataSyncJob dataSyncJob) {
        this.dataSyncJob = dataSyncJob;
        initializeJobRegistry();
    }

    private void initializeJobRegistry() {
        // 등록된 Job들을 Registry에 추가
        jobRegistry.put("dataSyncJob", dataSyncJob.createJob());
        // 추후 다른 Job 타입들 추가 가능
    }

    public Job getJob(String jobName) {
        Job job = jobRegistry.get(jobName);
        if (job == null) {
            throw new IllegalArgumentException("알 수 없는 Job 이름: " + jobName);
        }
        return job;
    }

    public JobParameters createJobParameters(BatchJobConfig jobConfig) {
        return new JobParametersBuilder()
                .addLong("jobConfigId", jobConfig.getJobConfigId())
                .addString("jobName", jobConfig.getJobName())
                .addString("schemaName", jobConfig.getSchemaName())
                .addString("tableName", jobConfig.getTableName())
                .addString("insertQuery", jobConfig.getInsertQuery())
                .addString("startDate", jobConfig.getStartDate().toString())
                .addString("endDate", jobConfig.getEndDate().toString())
                .addLong("timestamp", System.currentTimeMillis()) // 유니크한 실행을 위해
                .toJobParameters();
    }

    public JobParameters createManualJobParameters(BatchJobConfig jobConfig, String executedBy) {
        return new JobParametersBuilder()
                .addLong("jobConfigId", jobConfig.getJobConfigId())
                .addString("jobName", jobConfig.getJobName())
                .addString("schemaName", jobConfig.getSchemaName())
                .addString("tableName", jobConfig.getTableName())
                .addString("insertQuery", jobConfig.getInsertQuery())
                .addString("startDate", jobConfig.getStartDate().toString())
                .addString("endDate", jobConfig.getEndDate().toString())
                .addString("executedBy", executedBy)
                .addString("executionType", "MANUAL")
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();
    }

    public boolean isJobRegistered(String jobName) {
        return jobRegistry.containsKey(jobName);
    }

    public void registerJob(String jobName, Job job) {
        jobRegistry.put(jobName, job);
    }
}
```

### BatchJobExecutor.java 생성
- [ ] src/main/java/com/sbs/datasync/batch/BatchJobExecutor.java 파일 생성
```java
package com.sbs.datasync.batch;

import com.sbs.datasync.batch.job.BatchJobFactory;
import com.sbs.datasync.entity.BatchJobConfig;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class BatchJobExecutor {

    private final JobLauncher jobLauncher;
    private final BatchJobFactory jobFactory;

    public BatchJobExecutor(JobLauncher jobLauncher, BatchJobFactory jobFactory) {
        this.jobLauncher = jobLauncher;
        this.jobFactory = jobFactory;
    }

    /**
     * 동기식 Job 실행
     */
    public JobExecution executeJob(BatchJobConfig jobConfig) throws Exception {
        Job job = jobFactory.getJob("dataSyncJob");
        JobParameters parameters = jobFactory.createJobParameters(jobConfig);
        return jobLauncher.run(job, parameters);
    }

    /**
     * 비동기식 Job 실행
     */
    public CompletableFuture<JobExecution> executeJobAsync(BatchJobConfig jobConfig) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return executeJob(jobConfig);
            } catch (Exception e) {
                throw new RuntimeException("비동기 Job 실행 실패", e);
            }
        });
    }

    /**
     * 수동 실행 (실행자 정보 포함)
     */
    public JobExecution executeJobManually(BatchJobConfig jobConfig, String executedBy) throws Exception {
        Job job = jobFactory.getJob("dataSyncJob");
        JobParameters parameters = jobFactory.createManualJobParameters(jobConfig, executedBy);
        return jobLauncher.run(job, parameters);
    }

    /**
     * Job 실행 상태 확인
     */
    public boolean isJobRunning(Long jobInstanceId) {
        // JobExplorer를 통해 실행 중인지 확인하는 로직
        // 추후 구현
        return false;
    }
}
```

## 완료 확인 방법

### Spring Batch 설정 확인
- [ ] 애플리케이션 시작 시 Batch 관련 Bean 생성 로그 확인
- [ ] JobRepository, JobLauncher Bean 생성 확인

### 메타테이블 생성 확인
- [ ] BATCH_* 메타테이블들이 정상 생성되었는지 DB에서 확인
```sql
SELECT TABLE_NAME FROM SYSCAT.TABLES
WHERE TABSCHEMA = 'YOUR_SCHEMA' AND TABLE_NAME LIKE 'BATCH_%';
```

### Job 등록 및 실행 테스트
- [ ] BatchJobFactory에서 Job 등록 확인
- [ ] 기본 Tasklet으로 Job 실행 테스트
```java
@Test
void testJobExecution() throws Exception {
    JobExecution execution = batchJobExecutor.executeJob(testJobConfig);
    assertThat(execution.getStatus()).isEqualTo(BatchStatus.COMPLETED);
}
```

### 트랜잭션 매니저 동작 확인
- [ ] 배치 실행 시 트랜잭션이 올바르게 관리되는지 확인
- [ ] 롤백 시나리오 테스트

### Job 실행 로그 확인
- [ ] Job 시작/완료 로그가 올바르게 출력되는지 확인
- [ ] JobExecutionListener의 beforeJob, afterJob 메서드 실행 확인

## 주의 사항
- Spring Batch 5.x 버전의 새로운 설정 방식 적용
- DB2 데이터베이스와 Spring Batch 메타테이블 호환성 확인
- JobRepository와 비즈니스 데이터베이스의 트랜잭션 분리 고려

## 다음 단계
2.2 데이터 클론 배치 Job 개발로 진행